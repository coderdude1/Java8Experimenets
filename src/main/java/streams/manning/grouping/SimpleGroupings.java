package streams.manning.grouping;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import streams.manning.core.Dish;

import java.util.*;

import static java.util.Comparator.comparingInt;
import static java.util.stream.Collectors.*;

/**
 * the groupingBy method accepts a Function (T->R) which is referred to as a classification function in this usage
 * groupingBy returns a map of lists (like a multimap) and can be used to do some really cool complex stuff
 */
public class SimpleGroupings {
    private static final Logger LOG = LoggerFactory.getLogger(SimpleGroupings.class);

    public static void main(String[] args) {
        SimpleGroupings simpleGroupings = new SimpleGroupings();
        simpleGroupings.simpleGroupings();
        simpleGroupings.multiLevelGrouping();
        simpleGroupings.collectingInSubgroups();
    }

    /*
    groupingBy<Function<T>
     */
    private void simpleGroupings() {
        Map<Dish.Type, List<Dish>> dishesByType = Dish.createMenu().stream()
                .collect(groupingBy(Dish::getType));

        LOG.info("Dishes by type: {}", dishesByType);
    }

    private void multiLevelGrouping() {
        Map<Dish.Type, Map<CaloricLevel, List<Dish>>> dishesByCaloricLevel = Dish.createMenu().stream()
                .collect(groupingBy(Dish::getType,
                        groupingBy(dish -> {
                            if (dish.getCalories() <= 400) return CaloricLevel.DIET;
                            else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
                            else return CaloricLevel.FAT;
                        })));

        LOG.info("dishesByCaloricLevel: {}", dishesByCaloricLevel);
    }

    /*
    note the groupingBy in this example has a 2nd arg of type Collector
     */
    private void collectingInSubgroups() {
        Map<Dish.Type, Long> typesCount = Dish.createMenu().stream()
                .collect(groupingBy(Dish::getType, counting()));

        LOG.info("countOfDishesByType: {}", typesCount);

        //Optional is required due to collector generated by the maxBy
        Map<Dish.Type, Optional<Dish>> mostCaloricByType = Dish.createMenu().stream()
                .collect(groupingBy(Dish::getType,
                        maxBy(comparingInt(Dish::getCalories))));

        LOG.info("mostCaloricByType: {}", mostCaloricByType);

        //adapting  the collector result to a different type (in this case not wanting an Optional
        //collectingAndThen accepts a collector to be wrapped, and a transformation fn
        Map<Dish.Type, Dish> otherMostCaloricByType = Dish.createMenu().stream()
                .collect(groupingBy(Dish::getType,  //classificationFunction by DishType
                        collectingAndThen(
                                maxBy(comparingInt(Dish::getCalories)),//wrappedCollector (reducingCollector) created by maxBy
                                Optional::get)));//TransformationFunction, reducingCollector never returns an Optional.empty()

        LOG.info("mostCaloricByTypeWithoutOptional: {}", otherMostCaloricByType);

        //collector as 2nd arg is used to perform a further reduction operation
        Map<Dish.Type, Integer> totalCaloriesByType = Dish.createMenu().stream()
                .collect(groupingBy(Dish::getType,
                        summingInt(Dish::getCalories)));//this collector is a reduction op

        LOG.info("totalCalByType: {}", totalCaloriesByType);

        //use the mapping collector takes a transforming fn, and collector to accumulate
        //Dish in, Map of a set (unknown type of set) of CaloricLevels
        Map<Dish.Type, Set<CaloricLevel>> caloricLevelsByType = Dish.createMenu().stream()
                .collect(groupingBy(Dish::getType, mapping(
                        dish -> {
                            if (dish.getCalories() <= 400) return CaloricLevel.DIET;
                            else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
                            else return CaloricLevel.FAT;
                        }, toSet())
                ));

        LOG.info("caloricLevelsByType: {}", caloricLevelsByType);

        //use the mapping collector takes a transforming fn, and collector to accumulate
        //Dish in, Map of a set (unknown type of set) of CaloricLevels
        Map<Dish.Type, Set<CaloricLevel>> caloricLevelsByTypeWithHashset = Dish.createMenu().stream()
                .collect(groupingBy(Dish::getType, mapping(
                        dish -> {
                            if (dish.getCalories() <= 400) return CaloricLevel.DIET;
                            else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
                            else return CaloricLevel.FAT;
                        }, toCollection(HashSet::new))//toSet is a collector
                ));

        LOG.info("caloricLevelsByType Hashset: {}", caloricLevelsByType);
    }

}
